#+TITLE: Notes from Rust Introduction Tutorial
#+EMAIL: balaji AT balajisivaraman DOT com
#+AUTHOR: Balaji Sivaraman
#+LANGUAGE: en
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{amssymb, amsmath, mathtools, fullpage, fontspec}
#+LATEX_HEADER: \renewcommand*{\familydefault}{\sfdefault}
#+LATEX_HEADER: \setsansfont{Verdana}
#+LATEX: \newpage
* Getting Started
** Function names ending with ! indicate a Macro, this is how metaprogramming is done in Rust.
** "Hello, world!" is as statically allocated string. We'll return to this later.
* Guessing Game
** The Prelude gets imported by default to every program. There's also an IO Prelude, which gives useful functions for working with IO. This needs to be imported manually.
** No return type indicates (), an empty tuple.
** Rust variable bindings are immutable by default. When we say, let foo = bar, that creates an immutable binding. This is why we do `let mut`.
** The word on the left hand side of a let is not a variabe, it's a pattern.
** A String is a growable, UTF-8 encoded bit of text.
** The ::new() syntax uses :: because this is an ‘associated function’ of a particular type. That is to say, it’s associated with String itself, rather than a particular instance of a String. Some languages call this a ‘static method’.
** We call the read_line() method on our handle. Methods are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We’re also passing one argument to read_line(): &mut guess.
** Rust references are immutable by default. We'll return to this later. This is why we wrote &mut guess, instead of &guess.
** read_line() also returns a value: in this case, an io::Result. Rust has a number of types named Result in its standard library: a generic Result, and then specific versions for sub-libraries, like io::Result. The purpose of these Result types is to encode error handling information.
** The {}s are a placeholder, and so we pass it guess as an argument. If we had multiple {}s, we would pass multiple arguments.
** Cargo understands Semantic Versioning, which is a standard for writing version numbers. A bare number like above is actually shorthand for ^0.3.0, meaning "anything compatible with 0.3.0". If we wanted to use only 0.3.0 exactly, we could say rand="=0.3.0" (note the two equal signs). And if we wanted to use the latest version we could use *.
** Rust has Enums. Ordering is an Enum.
** Wait a minute, I thought we already had a guess? We do, but Rust allows us to ‘shadow’ the previous guess with a new one. This is often used in this exact situation, where guess starts as a String, but we want to convert it to an u32. Shadowing lets us re-use the guess name, rather than forcing us to come up with two unique names like guess_str and guess, or something else.
** Sidenote: Shadowing seems really useful for reusing variables with casting.
* Common Programming Concepts
** Variables and Mutability
*** If one part of the code operates under the assumption that a value will not change, and another part expects it to, that can cause problems.
*** 'mut' cannot be used with constants. They're immutable by defaut. They're declared using the word 'const'. They must always be annotated. They're not inferred.
*** Variables can be shadowed by using the 'let' keyword with the same variable name. This is different from marking a variable as mutable.
*** We can perform transformations on a variable, yet have it be immutable at the end of those transformations.
*** The other difference is that when shadowing you can change the type of the variable as we saw in the guessing game chapter.
*** We cannot do the above with 'mut' since that doesn't allow us to change a variable's type.
** Data Types
*** When more than one type is possible, such as when we used 'parse', we must add a type annotation. Rust doesn't automatically go with a default type, which is good news I guess.
*** Scalar Types
**** A scalar type represents a single value: integers, floating-point numbers, booleans and characters. (Analogous to primitive types in Java.)
**** i32 is always a good default to use when unsure of what type to use.
**** Rust has f32 and f64 floating point types. Using the latter in 32-bit systems is possible but slower, so we should benchmark our code to see whether that is the issue.
**** Mathematical operators are operators in Rust like usual and not functions like Scala.
**** Rust char type is a unicode scalar value. So it can represent characters, numbers and even emoji.
*** Compound Types
**** Rust has tuples and arrays.
**** Tuples can be destructured using pattern matching much like in Scala.
**** Tuple elements can also be accessed using 'tup.0', 'tup.1' etc.
**** Arrays in Rust have a fixed length, unlike other languages. Once declared, they cannot grow or shrink in size.
**** Arrays are allocated on the stack rather than the heap. If we're unsure, we can use the Vector provided by the stdlib as a safe bet.
**** Accessing an array index that is out of bounds is still a runtime exception. However, rust still checks whether the index is within the bounds of the array, thereby not allowing access to invalid memory.
** How Functions Work
*** Rust doesn't care where you define fns, so long as they're defined somewhere.
*** Statements perform some action and don't return a value. Expressions always evaluate to a value.
*** You can do, x = y = 6 in C or Ruby, but you cannot do let x = let y = 6 in Rust, because the let is a statement and not an expression. Statements cannot be bound to variables since they don't return a value.
*** Expressions do not include ending semicolons, if we do they become a statement, like the below example.
#+BEGIN_SRC rust
    let y = {
        let x = 3;
        x + 1
    };
#+END_SRC
*** Functions can return values. They are unnamed but we do need to declare their type.
#+BEGIN_SRC rust
    fn five() -> i32 {
        5
    }
#+END_SRC
*** Statements don't evaluate to a value, so putting a semi-colon when you expect the function to return a type is a compile time error. The evaluation of statements is represented by the empty tuple (), analogous to Unit in Scala.
** Control Flow
*** If expressions
**** Else blocks are optional, unlike Scala. If no else block is provided, and the condition evaluates to false, then the if block is skipped entirely and we move on to the next line.
**** Else blocks are not optional when you are assigning the result of an if block to a variable. Then it is treated as an expression and both sides are needed, resulting in a compile time error otherwise. Also the types in both the arms need to be the same, just like in Scala.
*** Loops
**** Like we saw in the guessing game chapter, a 'loop' just gives us an infinite loop.
* Understanding Ownership
** Languages like Java are garbage collected, while languages like C require you to manually manage the memory.
** Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. No run-time costs are incurred for any of the ownership features.
** The Stack and the Heap
*** Usually in most programming languages, we don't have to worry about the variable going into the stack or the heap. When I program in Java, this is usually the case.
*** But in a system's prog lang like Rust, it has more of an effect on how the program behaves.
*** Stack is a simple last in, first out data structure. All items on the stack must be of a known, fixed size. This and the previous property makes it very fast to use.
*** For data whose size is not known to us at compile time or whose size might change, we can store them on the heap instead.
*** When we allocate something here, we ask for the OS to find us an empty spot and give us a pointer to that location. This is called 'allocating on the heap' or more commonly 'allocating'.
*** Because a pointer always has a known, fixed size, they are pushed onto the stack.
*** Processors work better when they're working with data close to each other, like on a stack. Working with heap is slower, as is allocating a large amount of space on the heap.
*** When our code calls a function, the values passed in (including pointers to data) and the local variables in the fn are pushed onto the stack. When the fn is over, they're popped off.
** Ownership Rules
*** Each value in Rust has a variable that’s called its /owner/.
*** There can only be one owner at a time.
*** When the owner goes out of scope, the value will be dropped.
** All the variables we looked at in the data types chapter are stored on the stack and popped off when their scope is over.
** Memory and Allocation
*** For string literals, we know the exact amount of space needed to store them at compile time, making them very fast and efficient. We can't do the same for all strings. We can't just put a blob of memory into the binary for each piece of text whose size is unknown at compile time.
*** When we do 'String::new', it's implementation takes care of allocating space on the heap.
*** Deallocation
**** In languages with GC, this is done by that.
**** In manually managed langs like C, this is done by using a deallocation operation. This is tricky since if we forget, we waste memory. If we do it too early, we'll have an invalid variable. If we do it twice, that's a bug too.
**** We need exactly on pair of 'allocate' and 'free' statements.
**** In Rust, we return memory automatically when the variable goes out of scope.
**** When a variable goes out of scope, Rust calls a special function called 'drop'. This is the place where the author of String can put the code to return the memory.
**** In C++, this pattern of deallocating resources at the end of an item's lifetime is called Resource Acquisition Is Initialisation (RAII).
*** When we assign two strings to the same value, then when both go out of memory, then both might try to call free. This is known as double free error is one type of error that can occur.
*** Rust resolves this by invalidating the previous variable as soon as it is assigned to a new variable.
#+BEGIN_SRC rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world", s1);
#+END_SRC
*** In the above example, s1 is invalidated after the second line. This means the println line will not compile ensuring 'drop' is called only when 's2' goes out of scope.
*** This is neither a deep nor a shallow copy. We can consider this as a 'move', where s1 is moved into s2.
*** The advantage is that Rust will never automatically create deep copies of our data.
*** Types like integers have no notion of shallow or deep copy since they always reside on the stack. This is because we know their size at compile time itself.
*** Rust has a special annotation called the Copy trait. Types with this trait ensure that older variables are not invalidated when they are moved to newer variables.
*** Any type annotated with the Copy trait cannot also be annotated with the Drop trait.
*** All scalar types are Copyable. A tuple is copyable only if it contains scalar types.
*** Parameters to function calls behave the same way as let bindings. For scalar types, copies are made. For others, ownership is transferred onto the calling function.
*** When a variable is returned from a function, ownership is transferred to its caller.
** References and Borrowing
*** Borrowing and Immutable References
**** When we call a function as follows: calculate_length(&s1), we're not passing along ownership, but passing along a reference that refers to the value of s1.
**** We call having references as function parameters /borrowing/.
**** Just as variables are immutable by default, so are references. We cannot change something we borrowed. It is a compile time error.
*** Mutable Reference
**** The variable has to be marked as mutable, the function call has to pass a mutable reference, and the function itself must accept a mutable reference.
**** The big restriction is that you can have only one mutable reference to a particular piece of data in a particular scope.
**** This restriction allows for Rust to avoid data races at compile time.
**** Data Race
***** Two or more pointers access the same data at the same time
***** At least one of the pointers is being used to write to the data
***** There's no mechanism being used to synchronise access to the data
**** We also cannot have a mutable reference to something that already has an immutable reference
*** Dangling References
**** A pointer that references a location in memory that may have been give to someone else, when it was freed.
**** In Rust, the compile guarantees that there will be no dangling references.
** Slices
*** Taking a slice is very similar to getting a reference to the whole string, with the addition of specifying a range.
#+BEGIN_SRC rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+END_SRC
*** The type that indicates a String slice is written as &str.
*** String slices are immutable.
*** String literals are simply string slices that point to a specific point in the compiled binary.
*** String slices can also be used as parameters, by annotating parameter as &str instead of &String. This is more general and reusable.
*** There are other slices also, like below.
#+BEGIN_SRC rust
let a = [1, 2, 3, 4, 5];
let slice: &[i32] = &a[1..3];
#+END_SRC
* Using Structs to Structure Related Data
** Defining and Instantiating
*** Mutable struct instances values can be changed by using the dot notation.
*** If a variable name and struct field name are the same, then we can use shorthand notation and leave out the key-value pair notation in Struct instantiation.
*** We can create Tuple structs that look similar to Tuples, only that they have a name associated with them, like below.
 #+BEGIN_SRC rust
 struct Color(i32, i32, i32);
 #+END_SRC
*** So far we created Structs by specifying &String instead of &str. This is because we want the Struct to own its entire data. However, we can circumvent this by using lifetimes discussed later.
** Derived Traits
*** println! by default formats things based on the Display trait. These are implemented for all primitive types. But we should implement them for our Structs to let println! know how it should be printed.
*** If we use {:?}, the we're telling println! to use the output format provided by the Debug trait.
*** I'm thinking this is analogous to type classes, but we'll see more later.
** Methods on Traits
*** We define these like functions within an impl block for the trait.
*** Parameters can take ownership also if necessary, just like functions.
*** Taking ownership in a method is rare. We do this when we want to transform self to something else and ensure our caller doesn't use it in the future.
*** In C++, we use object->something() to mean the same as (*object).something(). The former syntax means dereference this pointer before calling something.
*** Rust has automatic referencing and dereferencing. Rust automatically adds in &, &mut, or * like follows:
 #+BEGIN_SRC rust
 p1.distance(&p2);
 (&p1).distance(&p2);
 #+END_SRC
*** They both mean the same thing in the context of method calling. This is because for methods, the first parameter is self, and we specify whether it should be a mutable borrow, immutable borrow or ownership transfer.
* Enum and Pattern Matching
** Woot! Enums are similar to ADTs in Haskell. I'm already giddy.
** Enums can hold any type of data, scalar types, compound types, structs, other enums.
** They can contain methods much like structs.
** Rust doesn't have NULL. This means unless we're working with Options, we can be safe to assume that a value is always present.
** Awesome! Rust matches are exhaustive. Non-exhaustive matches are compile time erros.
* Modules
** Defines using the mod keyword. Code can immediately follow it or be put in another file.
** By default everything is private. You use pub to make an item public and accessible to others.
** Privacy Rules
*** If an item is public, it can be accessed through any of its parent modules.
*** If an item is private, it can only be accessed by the current module and its child modules.
* Common Collections
** Vectors allows us to store more than one value in a single data structure that puts all values next to each other in memory.
** String is implemented as a collection of bytes, plus some functionality when those bytes are interpreted as text.
** String can be coerced into a &str. When we pass this, Rust uses something called /deref coercion/.
** Rust Strings don't support indexing. That is, s[0] is invalid.
** A String is a wrapper over a Vec<u8>.
** Since there would be confusion over whether to return the unicode value of an index or actual string and since different unicode characters are represented differently, Rust chooses not to allow String indexing.
** For owned values like String, if we insert an existing variable into a Hashmap, that becomes the owner of it, and we can't refer to the variable anymore in our program.
* Error Handling
** Rust has recoverable and unrecoverable errors.
** Unrecoverable Errors
*** Result<T, E> is there for the former and panic! macro is there for the latter.
*** When the panic! macro executes, the program will print a failure message, unwind and clean up the stack, and quit.
*** If we don't want to unwind, the alternative is to immediately abort, which means the OS has to clean up any memory we're using.
*** We can do this if we want our binary to be really small. We can add it to the profile section of our Cargo.toml file for release profile as well.
** Recoverable errors with Result
*** When matching on Err, we use 'ref' instead of '&' to take a reference. 'ref' matches and gives us a reference to it is the short answer.
*** We can use 'unwrap' to get the value out of Result. But this panics in case of Err value. We can also use 'expect' to give it an error message. No idea why we would ever do this as it's unsafe.
*** The ? operator is built to work with the Result type and is the same as matching on Result and handling both cases. If it's Ok, the value gets returned, if it's Err, it gets propagated.
*** ? can only be used within functions that themselves have a return type of Result. For example, we cannot use this within the main function.
** To Panic or Not to Panic
*** As we know, a good default is to return Result always and leave the decision making on how to handle the error at the hands of our caller.
* Generic Types, Traits and Lifetimes
** Generics
*** There's no runtime cost of using generics. Rust performs something called monomorphization of code at compile time. This is the process of turning generic code into specific code with concrete types that are actually used filled in.
*** When we use generic parameters, we can use /trait bounds/ to specify, at compile time, that the generic type may be any type that implements a trait and therefor has the behaviour we want to use in that situation.
*** When we implement traits, it follows a very similar syntax to creating instances of typeclasses in Haskell.
*** We aren't able to implement traits on external traits and external types. We can define if the trait is ours or the type is ours.
*** This restriction is part of the /orphan rule/ in type theory. It's called this because the parent type is not present.
*** Without this, two crates could implement the same trait for the same type, and the two implementations would conflict. Because of this rule, other people's code cannot break ours and vice versa.
*** If our trait contains a default implementation for a method, then we can just implement the trait for our type and have no definition.
*** Default implementations in the trait are allowed to call other methods, even if they don't have default implementations.
*** Trait bounds can be specified on generic types. Multiple ones can be specified with + operator.
*** We can also specify trait bounds at the end of definitions, using the where clause.
*** With normal types, we knew the amount of space needed to be allocated at compile time, so Rust would know how to move the value out of the list. That's not possible with generic values.
*** To enable list accessors on generic types, we also need to enable the Copy trait bound.
*** The above is needed only if we're returning the value by moving it out, if we're returning only a reference to it, we wouldn't need it.
** Lifetimes
*** Every reference in Rust has a lifetime. Most of the time lifetimes are inferred and implicit, just like types.
*** And similar to how we need to annotate types when they can't be inferred, we may need to annotate lifetimes as well.
*** The main aim of lifetimes is to prevent dangling references, which will cause the program to reference data that we're not intending to reference.
 #+BEGIN_SRC rust
 {
   let r;
   {
     let x = 5;
     r = &x;
   } // x goes out of scope here, so any reference to it will also be invalidated
  println!("r is {}", r); //since x has gone out of scope, r is invalid
 #+END_SRC
*** In the above case, we'll get an error saying 'x' does not live long enough.
*** The part of the compiler called the borrow checker does this checking. Basically, it sees that something with a larger lifetime is referring to something with a smaller lifetime and rejects the program.
*** There are some cases where the borrow checker cannot determine the lifetime in a straightforward fashion. Look at the string example in code.
*** In the same way a function can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime when the signature specifies a generic lifetime parameter. What lifetime annotations do is relate the lifetimes of multiple references to each other.
*** Lifetime annotations must begin with a ' followed by a short name, usually just a. For eg: 'a. They must be specified after the & of a reference.
 #+BEGIN_SRC rust
 &i32        // a reference
 &'a i32     // a reference with an explicit lifetime
 &'a mut i32 // a mutable reference with an explicit lifetime
 #+END_SRC
*** If we have a function accepting two parameters with the same lifetime parameter 'a, that means both parameters must live as long as 'a.
*** Lifetime parameters are usually only put in function signatures. This is because the body of the function can be figured out by the compiler. But when it is called multiple times from different places with different values and lifetimes, we need to help the compiler figure out the lifetimes.
*** When concrete references are passed to longest, the concrete lifetime that gets substituted for 'a is the part of the scope of x that overlaps with the scope of y. Since scopes always nest, another way to say this is that the generic lifetime 'a will get the concrete lifetime equal to the smaller of the lifetimes of x and y. Because we've annotated the returned reference with the same lifetime parameter 'a, the returned reference will therefore be guaranteed to be valid as long as the shorter of the lifetimes of x and y.
*** Lifetime Elision
**** In earlier versions of Rust, every function that took and returned references needed to be annotated. Like the below example:
 #+BEGIN_SRC rust
 fn first_word(s: &str) -> &str {
     let bytes = s.as_bytes();

     for (i, &item) in bytes.iter().enumerate() {
         if item == b' ' {
             return &s[..i];
         }
     }

     &s
 }
 #+END_SRC
**** However, the Rust core team found that some patterns emerged in the usage of lifetimes and programmed them into the compiler.
**** These are called /lifetime elision rules/. We don't have to follow these, but if code we write fits into them, Rust will fill in the lifetimes.
**** Lifetimes on method parameters are called /input lifetimes/ and those on return values are called /output lifetimes/.
**** The third lifetime elision rule states that, if of multiple parameters one of them is &self or &mut self, lifetime of self is assigned to all output parameters.
*** There is a special lifetime called 'static, whose lifetime is the entire duration of the program.
*** All string literals have the static lifetime. This is why the program where we declared a literal within an inner block worked.
* Testing
** Attributes are metadata about pieces of Rust code: remember the derive attribute we used to derive Debug for our struct in an earlier chapter.
** A test is a function that's annotated with the 'test' attribute.
** When we use assert_eq and assert_ne!, the values we use must implement the PartialEq and Debug traits.
** Use #[ignore] to ignore some tests unless specifically requested.
** Unit test approach is to put them together with the same code they're testing, in a module named tests, which is annotated with #[cfg(test)]
** The cfg means to compile the code, only in the test configuration.
** Other languages usually make it impossible to difficult private methods. But Rust doesn't. This is because of Rust's module rules. If we put test code in the child module of the parent module, we will be able to access the private functions.
** Even for binary projects, it usually makes sense to put all code in the lib crate that can be integration tested, and then call the code from the main function directly.
* FP Concepts in Rust
** Closures
*** In Scala, a lamba without type annotations will not compile at all. In Rust, the closure gets its types on first use and retains them. Any further use with different types will not compile.
*** Each closure instance has its own unique anonymous type: i.e. even if two closures have the same signature, their types are still considered to be different.
*** Instead of re-evaluating the closure each time, we can choose to hold the closure and the output value in a Struct, such that it is only evaluated the first time it is called and cached on further calls. Obviously this is memoization or lazy evaluation.
*** Closures can capture values from their environment in three ways. which are the same three ways a function can take paramaters: taking ownership, borrowing immutably, and borrowing mutably.
**** FnOnce takes ownership and moves the variables into the closure. Therefore, it can be called only once in the same context.
**** Fn borrws values from its environment immutably.
**** FnMut can change the environment since it mutably borrows values. (??? -> Needs more investigation.)
*** If we want to force a closure to take ownership, we can do so by using 'move' before the arguments list. This is useful when passing a closure to a new thread.
** Iterators
*** Rust iterators are lazy. They have no effect until we call some action that consumes them.
*** Check out why Rust iterator trait uses type alias for item, instead of generics.
*** By default, when we call .iter on a collection, we get an iterator that returns immutable references to the values.
*** If we wanted owned values, then we should call the into_iter method. If we wanted mutable references, we can call iter_mut.
*** Methods that call the next method are called /consuming adaptors/, since they use up the iterator. A good example would be sum.
*** Methods that produce other iterators are called /iterator adaptors/.
*** According to their benchmark, the iterator version is faster than writing your own for loop. This is because iterators are one of Rust's /zero-cost abstractions/. This means that we incur no runtime overhead by using them. This is the same as Stroustrup's /zero-overhead/.
