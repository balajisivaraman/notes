 #+TITLE: Notes from Rust Introduction Tutorial
#+EMAIL: balaji AT balajisivaraman DOT com
#+AUTHOR: Balaji Sivaraman
#+LANGUAGE: en
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{amssymb, amsmath, mathtools, fullpage, fontspec}
#+LATEX_HEADER: \renewcommand*{\familydefault}{\sfdefault}
#+LATEX_HEADER: \setsansfont{Verdana}
#+LATEX: \newpage
* Getting Started
** Function names ending with ! indicate a Macro, this is how metaprogramming is done in Rust.
** "Hello, world!" is as statically allocated string. We'll return to this later.
* Guessing Game
** The Prelude gets imported by default to every program. There's also an IO Prelude, which gives useful functions for working with IO. This needs to be imported manually.
** No return type indicates (), an empty tuple.
** Rust variable bindings are immutable by default. When we say, let foo = bar, that creates an immutable binding. This is why we do `let mut`.
** The word on the left hand side of a let is not a variabe, it's a pattern.
** A String is a growable, UTF-8 encoded bit of text.
** The ::new() syntax uses :: because this is an ‘associated function’ of a particular type. That is to say, it’s associated with String itself, rather than a particular instance of a String. Some languages call this a ‘static method’.
** We call the read_line() method on our handle. Methods are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We’re also passing one argument to read_line(): &mut guess.
** Rust references are immutable by default. We'll return to this later. This is why we wrote &mut guess, instead of &guess.
** read_line() also returns a value: in this case, an io::Result. Rust has a number of types named Result in its standard library: a generic Result, and then specific versions for sub-libraries, like io::Result. The purpose of these Result types is to encode error handling information.
** The {}s are a placeholder, and so we pass it guess as an argument. If we had multiple {}s, we would pass multiple arguments.
** Cargo understands Semantic Versioning, which is a standard for writing version numbers. A bare number like above is actually shorthand for ^0.3.0, meaning "anything compatible with 0.3.0". If we wanted to use only 0.3.0 exactly, we could say rand="=0.3.0" (note the two equal signs). And if we wanted to use the latest version we could use *.
** Rust has Enums. Ordering is an Enum.
** Wait a minute, I thought we already had a guess? We do, but Rust allows us to ‘shadow’ the previous guess with a new one. This is often used in this exact situation, where guess starts as a String, but we want to convert it to an u32. Shadowing lets us re-use the guess name, rather than forcing us to come up with two unique names like guess_str and guess, or something else.
** Sidenote: Shadowing seems really useful for reusing variables with casting.
* Common Programming Concepts
** Variables and Mutability
*** If one part of the code operates under the assumption that a value will not change, and another part expects it to, that can cause problems.
*** 'mut' cannot be used with constants. They're immutable by defaut. They're declared using the word 'const'. They must always be annotated. They're not inferred.
*** Variables can be shadowed by using the 'let' keyword with the same variable name. This is different from marking a variable as mutable.
*** We can perform transformations on a variable, yet have it be immutable at the end of those transformations.
*** The other difference is that when shadowing you can change the type of the variable as we saw in the guessing game chapter.
*** We cannot do the above with 'mut' since that doesn't allow us to change a variable's type.
** Data Types
*** When more than one type is possible, such as when we used 'parse', we must add a type annotation. Rust doesn't automatically go with a default type, which is good news I guess.
*** Scalar Types
**** A scalar type represents a single value: integers, floating-point numbers, booleans and characters. (Analogous to primitive types in Java.)
**** i32 is always a good default to use when unsure of what type to use.
**** Rust has f32 and f64 floating point types. Using the latter in 32-bit systems is possible but slower, so we should benchmark our code to see whether that is the issue.
**** Mathematical operators are operators in Rust like usual and not functions like Scala.
**** Rust char type is a unicode scalar value. So it can represent characters, numbers and even emoji.
*** Compound Types
**** Rust has tuples and arrays.
**** Tuples can be destructured using pattern matching much like in Scala.
**** Tuple elements can also be accessed using 'tup.0', 'tup.1' etc.
**** Arrays in Rust have a fixed length, unlike other languages. Once declared, they cannot grow or shrink in size.
**** Arrays are allocated on the stack rather than the heap. If we're unsure, we can use the Vector provided by the stdlib as a safe bet.
**** Accessing an array index that is out of bounds is still a runtime exception. However, rust still checks whether the index is within the bounds of the array, thereby not allowing access to invalid memory.
** How Functions Work
*** Rust doesn't care where you define fns, so long as they're defined somewhere.
*** Statements perform some action and don't return a value. Expressions always evaluate to a value.
*** You can do, x = y = 6 in C or Ruby, but you cannot do let x = let y = 6 in Rust, because the let is a statement and not an expression. Statements cannot be bound to variables since they don't return a value.
*** Expressions do not include ending semicolons, if we do they become a statement, like the below example.
#+BEGIN_SRC rust
    let y = {
        let x = 3;
        x + 1
    };
#+END_SRC
*** Functions can return values. They are unnamed but we do need to declare their type.
#+BEGIN_SRC rust
    fn five() -> i32 {
        5
    }
#+END_SRC
*** Statements don't evaluate to a value, so putting a semi-colon when you expect the function to return a type is a compile time error. The evaluation of statements is represented by the empty tuple (), analogous to Unit in Scala.
** Control Flow
*** If expressions
**** Else blocks are optional, unlike Scala. If no else block is provided, and the condition evaluates to false, then the if block is skipped entirely and we move on to the next line.
**** Else blocks are not optional when you are assigning the result of an if block to a variable. Then it is treated as an expression and both sides are needed, resulting in a compile time error otherwise. Also the types in both the arms need to be the same, just like in Scala.
*** Loops
**** Like we saw in the guessing game chapter, a 'loop' just gives us an infinite loop.
* Understanding Ownership
** Languages like Java are garbage collected, while languages like C require you to manually manage the memory.
** Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. No run-time costs are incurred for any of the ownership features.
** The Stack and the Heap
*** Usually in most programming languages, we don't have to worry about the variable going into the stack or the heap. When I program in Java, this is usually the case.
*** But in a system's prog lang like Rust, it has more of an effect on how the program behaves.
*** Stack is a simple last in, first out data structure. All items on the stack must be of a known, fixed size. This and the previous property makes it very fast to use.
*** For data whose size is not known to us at compile time or whose size might change, we can store them on the heap instead.
*** When we allocate something here, we ask for the OS to find us an empty spot and give us a pointer to that location. This is called 'allocating on the heap' or more commonly 'allocating'.
*** Because a pointer always has a known, fixed size, they are pushed onto the stack.
*** Processors work better when they're working with data close to each other, like on a stack. Working with heap is slower, as is allocating a large amount of space on the heap.
*** When our code calls a function, the values passed in (including pointers to data) and the local variables in the fn are pushed onto the stack. When the fn is over, they're popped off.
** Ownership Rules
*** Each value in Rust has a variable that’s called its /owner/.
*** There can only be one owner at a time.
*** When the owner goes out of scope, the value will be dropped.
** All the variables we looked at in the data types chapter are stored on the stack and popped off when their scope is over.
** Memory and Allocation
*** For string literals, we know the exact amount of space needed to store them at compile time, making them very fast and efficient. We can't do the same for all strings. We can't just put a blob of memory into the binary for each piece of text whose size is unknown at compile time.
*** When we do 'String::new', it's implementation takes care of allocating space on the heap.
*** Deallocation
**** In languages with GC, this is done by that.
**** In manually managed langs like C, this is done by using a deallocation operation. This is tricky since if we forget, we waste memory. If we do it too early, we'll have an invalid variable. If we do it twice, that's a bug too.
**** We need exactly on pair of 'allocate' and 'free' statements.
**** In Rust, we return memory automatically when the variable goes out of scope.
**** When a variable goes out of scope, Rust calls a special function called 'drop'. This is the place where the author of String can put the code to return the memory.
**** In C++, this pattern of deallocating resources at the end of an item's lifetime is called Resource Acquisition Is Initialisation (RAII).
*** When we assign two strings to the same value, then when both go out of memory, then both might try to call free. This is known as double free error is one type of error that can occur.
*** Rust resolves this by invalidating the previous variable as soon as it is assigned to a new variable.
#+BEGIN_SRC rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world", s1);
#+END_SRC
*** In the above example, s1 is invalidated after the second line. This means the println line will not compile ensuring 'drop' is called only when 's2' goes out of scope.
*** This is neither a deep nor a shallow copy. We can consider this as a 'move', where s1 is moved into s2.
*** The advantage is that Rust will never automatically create deep copies of our data.
*** Types like integers have no notion of shallow or deep copy since they always reside on the stack. This is because we know their size at compile time itself.
*** Rust has a special annotation called the Copy trait. Types with this trait ensure that older variables are not invalidated when they are moved to newer variables.
*** Any type annotated with the Copy trait cannot also be annotated with the Drop trait.
*** All scalar types are Copyable. A tuple is copyable only if it contains scalar types.
*** Parameters to function calls behave the same way as let bindings. For scalar types, copies are made. For others, ownership is transferred onto the calling function.
*** When a variable is returned from a function, ownership is transferred to its caller.
** References and Borrowing
*** Borrowing and Immutable References
**** When we call a function as follows: calculate_length(&s1), we're not passing along ownership, but passing along a reference that refers to the value of s1.
**** We call having references as function parameters /borrowing/.
**** Just as variables are immutable by default, so are references. We cannot change something we borrowed. It is a compile time error.
*** Mutable Reference
**** The variable has to be marked as mutable, the function call has to pass a mutable reference, and the function itself must accept a mutable reference.
**** The big restriction is that you can have only one mutable reference to a particular piece of data in a particular scope.
**** This restriction allows for Rust to avoid data races at compile time.
**** Data Race
***** Two or more pointers access the same data at the same time
***** At least one of the pointers is being used to write to the data
***** There's no mechanism being used to synchronise access to the data
**** We also cannot have a mutable reference to something that already has an immutable reference
*** Dangling References
**** A pointer that references a location in memory that may have been give to someone else, when it was freed.
**** In Rust, the compile guarantees that there will be no dangling references.
** Slices
*** Taking a slice is very similar to getting a reference to the whole string, with the addition of specifying a range.
#+BEGIN_SRC rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+END_SRC
*** The type that indicates a String slice is written as &str.
*** String slices are immutable.
*** String literals are simply string slices that point to a specific point in the compiled binary.
*** String slices can also be used as parameters, by annotating parameter as &str instead of &String. This is more general and reusable.
*** There are other slices also, like below.
#+BEGIN_SRC rust
let a = [1, 2, 3, 4, 5];
let slice: &[i32] = &a[1..3];
#+END_SRC
* Using Structs to Structure Related Data
** Defining and Instantiating
*** Mutable struct instances values can be changed by using the dot notation.
*** If a variable name and struct field name are the same, then we can use shorthand notation and leave out the key-value pair notation in Struct instantiation.
*** We can create Tuple structs that look similar to Tuples, only that they have a name associated with them, like below.
 #+BEGIN_SRC rust
 struct Color(i32, i32, i32);
 #+END_SRC
*** So far we created Structs by specifying &String instead of &str. This is because we want the Struct to own its entire data. However, we can circumvent this by using lifetimes discussed later.
** Derived Traits
*** println! by default formats things based on the Display trait. These are implemented for all primitive types. But we should implement them for our Structs to let println! know how it should be printed.
*** If we use {:?}, the we're telling println! to use the output format provided by the Debug trait.
*** I'm thinking this is analogous to type classes, but we'll see more later.
** Methods on Traits
*** We define these like functions within an impl block for the trait.
*** Parameters can take ownership also if necessary, just like functions.
*** Taking ownership in a method is rare. We do this when we want to transform self to something else and ensure our caller doesn't use it in the future.
*** In C++, we use object->something() to mean the same as (*object).something(). The former syntax means dereference this pointer before calling something.
*** Rust has automatic referencing and dereferencing. Rust automatically adds in &, &mut, or * like follows:
 #+BEGIN_SRC rust
 p1.distance(&p2);
 (&p1).distance(&p2);
 #+END_SRC
*** They both mean the same thing in the context of method calling. This is because for methods, the first parameter is self, and we specify whether it should be a mutable borrow, immutable borrow or ownership transfer.
* Enum and Pattern Matching
** Woot! Enums are similar to ADTs in Haskell. I'm already giddy.
** Enums can hold any type of data, scalar types, compound types, structs, other enums.
** They can contain methods much like structs.
** Rust doesn't have NULL. This means unless we're working with Options, we can be safe to assume that a value is always present.
** Awesome! Rust matches are exhaustive. Non-exhaustive matches are compile time erros.
* Modules
** Defines using the mod keyword. Code can immediately follow it or be put in another file.
** By default everything is private. You use pub to make an item public and accessible to others.
** Privacy Rules
*** If an item is public, it can be accessed through any of its parent modules.
*** If an item is private, it can only be accessed by the current module and its child modules.
* Common Collections
** Vectors allows us to store more than one value in a single data structure that puts all values next to each other in memory.
** String is implemented as a collection of bytes, plus some functionality when those bytes are interpreted as text.
** String can be coerced into a &str. When we pass this, Rust uses something called /deref coercion/.
** Rust Strings don't support indexing. That is, s[0] is invalid.
** A String is a wrapper over a Vec<u8>.
** Since there would be confusion over whether to return the unicode value of an index or actual string and since different unicode characters are represented differently, Rust chooses not to allow String indexing.
** For owned values like String, if we insert an existing variable into a Hashmap, that becomes the owner of it, and we can't refer to the variable anymore in our program.
* Error Handling
** Rust has recoverable and unrecoverable errors.
** Unrecoverable Errors
*** Result<T, E> is there for the former and panic! macro is there for the latter.
*** When the panic! macro executes, the program will print a failure message, unwind and clean up the stack, and quit.
*** If we don't want to unwind, the alternative is to immediately abort, which means the OS has to clean up any memory we're using.
*** We can do this if we want our binary to be really small. We can add it to the profile section of our Cargo.toml file for release profile as well.
** Recoverable errors with Result
*** When matching on Err, we use 'ref' instead of '&' to take a reference. 'ref' matches and gives us a reference to it is the short answer.
*** We can use 'unwrap' to get the value out of Result. But this panics in case of Err value. We can also use 'expect' to give it an error message. No idea why we would ever do this as it's unsafe.
*** The ? operator is built to work with the Result type and is the same as matching on Result and handling both cases. If it's Ok, the value gets returned, if it's Err, it gets propagated.
*** ? can only be used within functions that themselves have a return type of Result. For example, we cannot use this within the main function.
** To Panic or Not to Panic
*** As we know, a good default is to return Result always and leave the decision making on how to handle the error at the hands of our caller.
* Generic Types, Traits and Lifetimes
** Generics
*** There's no runtime cost of using generics. Rust performs something called monomorphization of code at compile time. This is the process of turning generic code into specific code with concrete types that are actually used filled in.
*** When we use generic parameters, we can use /trait bounds/ to specify, at compile time, that the generic type may be any type that implements a trait and therefor has the behaviour we want to use in that situation.
*** When we implement traits, it follows a very similar syntax to creating instances of typeclasses in Haskell.
*** We aren't able to implement traits on external traits and external types. We can define if the trait is ours or the type is ours.
*** This restriction is part of the /orphan rule/ in type theory. It's called this because the parent type is not present.
*** Without this, two crates could implement the same trait for the same type, and the two implementations would conflict. Because of this rule, other people's code cannot break ours and vice versa.
*** If our trait contains a default implementation for a method, then we can just implement the trait for our type and have no definition.
*** Default implementations in the trait are allowed to call other methods, even if they don't have default implementations.
*** Trait bounds can be specified on generic types. Multiple ones can be specified with + operator.
*** We can also specify trait bounds at the end of definitions, using the where clause.
*** With normal types, we knew the amount of space needed to be allocated at compile time, so Rust would know how to move the value out of the list. That's not possible with generic values.
*** To enable list accessors on generic types, we also need to enable the Copy trait bound.
*** The above is needed only if we're returning the value by moving it out, if we're returning only a reference to it, we wouldn't need it.
** Lifetimes
*** Every reference in Rust has a lifetime. Most of the time lifetimes are inferred and implicit, just like types.
*** And similar to how we need to annotate types when they can't be inferred, we may need to annotate lifetimes as well.
*** The main aim of lifetimes is to prevent dangling references, which will cause the program to reference data that we're not intending to reference.
 #+BEGIN_SRC rust
 {
   let r;
   {
     let x = 5;
     r = &x;
   } // x goes out of scope here, so any reference to it will also be invalidated
  println!("r is {}", r); //since x has gone out of scope, r is invalid
 #+END_SRC
*** In the above case, we'll get an error saying 'x' does not live long enough.
*** The part of the compiler called the borrow checker does this checking. Basically, it sees that something with a larger lifetime is referring to something with a smaller lifetime and rejects the program.
*** There are some cases where the borrow checker cannot determine the lifetime in a straightforward fashion. Look at the string example in code.
*** In the same way a function can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime when the signature specifies a generic lifetime parameter. What lifetime annotations do is relate the lifetimes of multiple references to each other.
*** Lifetime annotations must begin with a ' followed by a short name, usually just a. For eg: 'a. They must be specified after the & of a reference.
 #+BEGIN_SRC rust
 &i32        // a reference
 &'a i32     // a reference with an explicit lifetime
 &'a mut i32 // a mutable reference with an explicit lifetime
 #+END_SRC
*** If we have a function accepting two parameters with the same lifetime parameter 'a, that means both parameters must live as long as 'a.
*** Lifetime parameters are usually only put in function signatures. This is because the body of the function can be figured out by the compiler. But when it is called multiple times from different places with different values and lifetimes, we need to help the compiler figure out the lifetimes.
*** When concrete references are passed to longest, the concrete lifetime that gets substituted for 'a is the part of the scope of x that overlaps with the scope of y. Since scopes always nest, another way to say this is that the generic lifetime 'a will get the concrete lifetime equal to the smaller of the lifetimes of x and y. Because we've annotated the returned reference with the same lifetime parameter 'a, the returned reference will therefore be guaranteed to be valid as long as the shorter of the lifetimes of x and y.
*** Lifetime Elision
**** In earlier versions of Rust, every function that took and returned references needed to be annotated. Like the below example:
 #+BEGIN_SRC rust
 fn first_word(s: &str) -> &str {
     let bytes = s.as_bytes();

     for (i, &item) in bytes.iter().enumerate() {
         if item == b' ' {
             return &s[..i];
         }
     }

     &s
 }
 #+END_SRC
**** However, the Rust core team found that some patterns emerged in the usage of lifetimes and programmed them into the compiler.
**** These are called /lifetime elision rules/. We don't have to follow these, but if code we write fits into them, Rust will fill in the lifetimes.
**** Lifetimes on method parameters are called /input lifetimes/ and those on return values are called /output lifetimes/.
**** The third lifetime elision rule states that, if of multiple parameters one of them is &self or &mut self, lifetime of self is assigned to all output parameters.
*** There is a special lifetime called 'static, whose lifetime is the entire duration of the program.
*** All string literals have the static lifetime. This is why the program where we declared a literal within an inner block worked.
* Testing
** Attributes are metadata about pieces of Rust code: remember the derive attribute we used to derive Debug for our struct in an earlier chapter.
** A test is a function that's annotated with the 'test' attribute.
** When we use assert_eq and assert_ne!, the values we use must implement the PartialEq and Debug traits.
** Use #[ignore] to ignore some tests unless specifically requested.
** Unit test approach is to put them together with the same code they're testing, in a module named tests, which is annotated with #[cfg(test)]
** The cfg means to compile the code, only in the test configuration.
** Other languages usually make it impossible to difficult private methods. But Rust doesn't. This is because of Rust's module rules. If we put test code in the child module of the parent module, we will be able to access the private functions.
** Even for binary projects, it usually makes sense to put all code in the lib crate that can be integration tested, and then call the code from the main function directly.
* FP Concepts in Rust
** Closures
*** In Scala, a lamba without type annotations will not compile at all. In Rust, the closure gets its types on first use and retains them. Any further use with different types will not compile.
*** Each closure instance has its own unique anonymous type: i.e. even if two closures have the same signature, their types are still considered to be different.
*** Instead of re-evaluating the closure each time, we can choose to hold the closure and the output value in a Struct, such that it is only evaluated the first time it is called and cached on further calls. Obviously this is memoization or lazy evaluation.
*** Closures can capture values from their environment in three ways. which are the same three ways a function can take paramaters: taking ownership, borrowing immutably, and borrowing mutably.
**** FnOnce takes ownership and moves the variables into the closure. Therefore, it can be called only once in the same context.
**** Fn borrws values from its environment immutably.
**** FnMut can change the environment since it mutably borrows values. (??? -> Needs more investigation.)
*** If we want to force a closure to take ownership, we can do so by using 'move' before the arguments list. This is useful when passing a closure to a new thread.
** Iterators
*** Rust iterators are lazy. They have no effect until we call some action that consumes them.
*** Check out why Rust iterator trait uses type alias for item, instead of generics.
*** By default, when we call .iter on a collection, we get an iterator that returns immutable references to the values.
*** If we wanted owned values, then we should call the into_iter method. If we wanted mutable references, we can call iter_mut.
*** Methods that call the next method are called /consuming adaptors/, since they use up the iterator. A good example would be sum.
*** Methods that produce other iterators are called /iterator adaptors/.
*** According to their benchmark, the iterator version is faster than writing your own for loop. This is because iterators are one of Rust's /zero-cost abstractions/. This means that we incur no runtime overhead by using them. This is the same as Stroustrup's /zero-overhead/.
* Cargo
** dev, release, test and doc -> Pretty self-explanatory. We can customise them by using [profile.*] tags in Cargo.toml files.
** Documentation comments use /// instead of // and allow embedding markdown syntax in them. Code examples must be wrapped within ``` blocks.
** //! comments are typically usd to document the crate or the module, found in lib.rs or mod.rs.
** Use pub::use to re-export your internal stuff to the outside world conveniently.
** A cargo workspace is a set of packages that will all share the same Cargo.lock and output directory.
* Smart Pointers
** Introduction
*** Rust's references are data structures that act like a pointer, but also have additional metadata and capabilities, such as reference counting.
*** The difference between plain references and smart pointers is that references are a kind of pointer that only borrow data; but smart pointers own the data they point to.
*** In a certain sense, String and Vectors are smart pointers, because they both know additional information about the data they hold such as their length and the fact that String data will always be valid UTF-8.
*** All smart pointers need to implement the Deref and Drop traits.
** Box
*** Allows putting data on a heap and has a known fixed size.
*** When a boxed value goes out of scope, deallocation happens for both the box (stored on the stack) and the data it points to (stored on the heap).
*** In a recursive type like Cons list, Rust cannot figure out how much space is to be allocated.
*** In contrast, if we use a Box type, the it needs only fixed space to be allocated. This is because Box is always a pointer that takes up usize amount of space. The heap data can be of any size, but the address to the start of that heap data will always fit in a usize.
** Deref
*** This trait allows us to override '*', the dereference operator. Overriding this for smart pointers makes accessing the data behind the smart pointer convenient.
*** When dereferencing a reference, it is straightforward, since there's only one value the reference is pointing to. Smart pointers contain metadata also, so when we dereference, we only wane the data and not the metadata. So we override the * for this, by implementing the Deref trait.
*** With this trait, the compiler knows that types implementing it have a deref method that returns a reference.
*** The reason deref returns a reference is because of ownership. If it returned a value directly, then that would be moved out of self, and we don't want that in most cases where we use the dereference operator.
*** When we do *some_value, Rust replaces it as *(some_value.deref()). This happens once for each * operator.
*** A deref coercion will automatically convert a reference to any pointer into a reference to that pointer's contents. This happens when the reference type of the argument passed into the function differs from the reference type of the parameter defined in that function's signature.
** Drop
*** This lets us run some code when a value is about to go out of scope.
*** We can use std::mem::drop() to drop a value earlier than it goes out of scope, thought this is usually unnecessary.
*** The above function can take any type T and does nothing in its body. But it's useful because it takes ownership of the value passed and that value automatically goes out of scope at the end of the function, so Rust calls drop for us. It's magic!
** Reference Counting
*** This means keeping track of the number of references to a value in order to know if it is still in use or not. If there are zero references, we know we can cleanup the value without any references becoming invalid.
*** Rc<T> is for when we want to allocate data on the heap for multiple parts of our program to read, but we don't know which part will finish using it last. If we did, we can make that part the owner of the data and be done with it.
*** Cloning an Rc<T> increases the reference count
*** Rc<T> only allows us to have immutable references to the T value contained within.
** Refcell and the Interior Mutability Pattern
*** Interior mutability is a design pattern in Rust that allows you to mutate data even though there are immutable references to it, which would normally be disallowed by the borrowing rules.
*** We use unsafe code when we can ensure that the borrowing rules will be enforced at runtime, even when we can't enforce them at compile time.
*** References and Box<T> enforce borrowing rules at compile time. Failure results in a compile time error. Refcell<T> enforces them at runtime. Failure results in a panic!.
*** Refcell is useful when we know the borrowing rules are enforced, but the compiler, being more conservative, cannot be sure.
*** We use the borrow() and borrow_mut() functions on RefCell to get mutable and immutable references. These can be passed to any function that expects these types as per normal.
*** If we create two mutable references normally, we get a compile time error. If we do two borrow_mut() on a Refcell, we get a runtime panic.
*** Important: Checking borrowing rules in a running program has performance penalties.
*** We can combine Rc and Refcell to create a reference that is reference counted but also mutable.
** Safety of Smart Pointers
*** Preventing memory leaks is not one of Rust's guarantees. It does not make it impossible.
*** Weak<T> is a way to reference an Rc<T> that does not increment strong_count, instead it increments weak_count. When the Rc goes out of scope, it is dropped if it's strong_count is 0, even it it's weak_count is not 0.
*** To get a value out of a Weak, we have to upgrade it to an Option using the upgrade method. If the Rc hasn't been dropped, we'll get a Some. If it has, we'll get a None.
*** When we do, '*leaf.parent.borrow_mut() = Rc::downgrade(&branch)', this increases branch's weak count to 1, since leaf has a weak reference to it, and not the other way round. Need to read up more on this.
* Fearless Concurrency
** Threads
*** Many PLs provide lightweight or green threads. They take a number of green threads and execute them in the context of a number of OS threads.
*** The model where a language directly calls the OS API to create threads is called 1:1.
*** The green threaded model is called the M:N model, M green threads per N OS threads, where they're not necessarily the same number.
*** Rust's primary concern is with keeping the runtime binary as small as possible. The green threading model results in a significantly larger runtime. So Rust only provides an implementation of the 1:1 threading model.
*** thread::spawn returns a new JoinHandle. This is a owned value that can wait for a thread to finish, which is what the join method does.
*** When we call join, that's blocking. The main thread waits for the processing inside the thread to complete before continuing.
*** When a closure captures a value, Rust will best try to infer how to capture it. If all it needs is a reference in the new thread, it cannot, because we don't know how long the thread will live for. The thread may outlive the borrowed value's lifetime.
*** By putting 'move' before a closure, we force it to take ownership of any captured value. Of course, this means the value can no longer be used once it is passed into the closure.
** Message Passing
*** Channel is the primary tool that enables us to do message passing. It has two halves, a transmitter and a receiver.
*** mpsc::channel creates a tuple where the first element is the sending end and the second element is the receiving end. MPSC stands for multiple producer, single consumer.
*** tx.send returns a Result, because if the receiving thread has already stopped, then there's nowhere to send to. So the error needs to be handled.
*** rx.recv() will block execution until a value is sent down the channel.
*** tx.send takes ownership of its parameter and moves the value so that its now owned by the receiver.
*** The rx channel can itself be treated as an iterator.
*** We can create multiple producers by cloning the tx part of the channel.
** Shared State Concurrency
*** Mutexes allow only one thread to access a data at any given time. They're hard for the following reasons:
**** You have to remember to acquire the lock before using the data.
**** Once you're done with the data that's being guarded by the mutex, you have to remember to unlock the data so that other threads can acquire the lock.
*** Calling the lock method on mutex will block until it's our turn to have the lock. It can also fail if the thread holding the lock panicked.
*** Mutex<T> is a smart pointer. The call to 'lock' returns a smart pointer called MutexGuard. The latter also implements the Drop trait so we can't possibly forget to release the lock.
*** We cannot use Rc for reference counting since it's implemented for a single-threaded context. Using it for multiple threads could result in subtle bugs where the count is wrong and lead to memory leaks or dropping a value before we're done with it.
*** Luckily, there'a type called Arc in std::sync, which is like Rc, but for multiple threads.
*** Even though a Mutex is immutable, we can mutate the value inside it. Just like Cell, it provides internal mutability.
*** Rust does not prevent deadlocks where two threads hold locks to a resource the other needs to complete the operation.
** Extensible Concurrency
*** Send trait indicates that ownership may be transferred b/w threads. Most std lib types in Rust are Send. One exception is Rc, as we already know. Most primitives are also Send, except Raw Pointers.
*** Sync trait indicates that a type is safe to have references from multiple threads. A type T is Sync if &T is Send, so that the reference can be sent safely to another thread.
*** Most primitives are also Sync and any type composed entirely of Sync types is also Sync.
*** Both of these are marker traits, like Serializable in Java.
* OO Features in Rust
** If we think of it, enums and structs can be considered as OO, since the definitions contain the data and the impl contain the methods that operate on that data.
** We can provide encapsulation and data hiding by ensuring the fields are marked private, and the only way to modify them is using the public methods in the impl.
** There is no way for one struct to inherit another struct's fields. Thus it does not have inheritance in the traditional sense.
** A trait object is a trait behind some sort of a pointer, such as a & reference or a Box<T> smart pointer.
** Enums and Structs cannot be called objects in the traditional sense, since the data and the operations are separated from each other. In this sense, Trait Objects can be called objects. However, trait objects don't allow us to add data to it.
** A trait defines behaviour we need. We can then use it as a trait object in places where we would use a concrete type or a generic type. The type system will ensure that any value we substitute for the trait object will implement methods on the trait.
** As we already know, if we use generics, the compiler inlines the generic implementations with the concrete type during compilation. So the code is actually doing static dispatch, leading the very fast runtime performance.
** If we use Trait Objects, Rust cannot perform these optimisations since it can't know all possible types that can come up. It keeps track of the code that could be called and the dispatches the call appropriately.
** Not all traits can be made into trait objects. Only object-safe traits can. A trait is object safe if:
*** The trait does not require Self to be Sized
*** All of the trait's methods are object safe
** Self is a keyword that is an alias for the type that we're implementing traits or methods on.
** Sized is a marker trait like Send or Sync. It is automatically implemented on types that have a known size at compile-time (i32 and references). Types that don't have a known size include slices ([T]) and trait objects.
** Sized is an implicit trait bound on all generic type parameters by default. Most useful operations in Rust require a type to be Sized. We can opt out of this by specifying T: ?Sized.
** Traits have the above opt-in by default.
