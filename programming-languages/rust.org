#+TITLE: Notes from Rust Introduction Tutorial
#+EMAIL: balaji AT balajisivaraman DOT com
#+AUTHOR: Balaji Sivaraman
#+LANGUAGE: en
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{amssymb, amsmath, mathtools, fullpage, fontspec}
#+LATEX_HEADER: \renewcommand*{\familydefault}{\sfdefault}
#+LATEX_HEADER: \setsansfont{Verdana}
#+LATEX: \newpage
* Getting Started
** Function names ending with ! indicate a Macro, this is how metaprogramming is done in Rust.
** "Hello, world!" is as statically allocated string. We'll return to this later.
* Guessing Game
** The Prelude gets imported by default to every program. There's also an IO Prelude, which gives useful functions for working with IO. This needs to be imported manually.
** No return type indicates (), an empty tuple.
** Rust variable bindings are immutable by default. When we say, let foo = bar, that creates an immutable binding. This is why we do `let mut`.
** The word on the left hand side of a let is not a variabe, it's a pattern.
** A String is a growable, UTF-8 encoded bit of text.
** The ::new() syntax uses :: because this is an ‘associated function’ of a particular type. That is to say, it’s associated with String itself, rather than a particular instance of a String. Some languages call this a ‘static method’.
** We call the read_line() method on our handle. Methods are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We’re also passing one argument to read_line(): &mut guess.
** Rust references are immutable by default. We'll return to this later. This is why we wrote &mut guess, instead of &guess.
** read_line() also returns a value: in this case, an io::Result. Rust has a number of types named Result in its standard library: a generic Result, and then specific versions for sub-libraries, like io::Result. The purpose of these Result types is to encode error handling information.
** The {}s are a placeholder, and so we pass it guess as an argument. If we had multiple {}s, we would pass multiple arguments.
** Cargo understands Semantic Versioning, which is a standard for writing version numbers. A bare number like above is actually shorthand for ^0.3.0, meaning "anything compatible with 0.3.0". If we wanted to use only 0.3.0 exactly, we could say rand="=0.3.0" (note the two equal signs). And if we wanted to use the latest version we could use *.
** Rust has Enums. Ordering is an Enum.
** Wait a minute, I thought we already had a guess? We do, but Rust allows us to ‘shadow’ the previous guess with a new one. This is often used in this exact situation, where guess starts as a String, but we want to convert it to an u32. Shadowing lets us re-use the guess name, rather than forcing us to come up with two unique names like guess_str and guess, or something else.
** Sidenote: Shadowing seems really useful for reusing variables with casting.
* Common Programming Concepts
** Variables and Mutability
*** If one part of the code operates under the assumption that a value will not change, and another part expects it to, that can cause problems.
*** 'mut' cannot be used with constants. They're immutable by defaut. They're declared using the word 'const'. They must always be annotated. They're not inferred.
*** Variables can be shadowed by using the 'let' keyword with the same variable name. This is different from marking a variable as mutable.
*** We can perform transformations on a variable, yet have it be immutable at the end of those transformations.
*** The other difference is that when shadowing you can change the type of the variable as we saw in the guessing game chapter.
*** We cannot do the above with 'mut' since that doesn't allow us to change a variable's type.
** Data Types
*** When more than one type is possible, such as when we used 'parse', we must add a type annotation. Rust doesn't automatically go with a default type, which is good news I guess.
*** Scalar Types
**** A scalar type represents a single value: integers, floating-point numbers, booleans and characters. (Analogous to primitive types in Java.)
**** i32 is always a good default to use when unsure of what type to use.
**** Rust has f32 and f64 floating point types. Using the latter in 32-bit systems is possible but slower, so we should benchmark our code to see whether that is the issue.
**** Mathematical operators are operators in Rust like usual and not functions like Scala.
**** Rust char type is a unicode scalar value. So it can represent characters, numbers and even emoji.
*** Compound Types
**** Rust has tuples and arrays.
**** Tuples can be destructured using pattern matching much like in Scala.
**** Tuple elements can also be accessed using 'tup.0', 'tup.1' etc.
**** Arrays in Rust have a fixed length, unlike other languages. Once declared, they cannot grow or shrink in size.
**** Arrays are allocated on the stack rather than the heap. If we're unsure, we can use the Vector provided by the stdlib as a safe bet.
**** Accessing an array index that is out of bounds is still a runtime exception. However, rust still checks whether the index is within the bounds of the array, thereby not allowing access to invalid memory.
** How Functions Work
*** Rust doesn't care where you define fns, so long as they're defined somewhere.
*** Statements perform some action and don't return a value. Expressions always evaluate to a value.
*** You can do, x = y = 6 in C or Ruby, but you cannot do let x = let y = 6 in Rust, because the let is a statement and not an expression. Statements cannot be bound to variables since they don't return a value.
*** Expressions do not include ending semicolons, if we do they become a statement, like the below example.
#+BEGIN_SRC rust
    let y = {
        let x = 3;
        x + 1
    };
#+END_SRC
*** Functions can return values. They are unnamed but we do need to declare their type.
#+BEGIN_SRC rust
    fn five() -> i32 {
        5
    }
#+END_SRC
*** Statements don't evaluate to a value, so putting a semi-colon when you expect the function to return a type is a compile time error. The evaluation of statements is represented by the empty tuple (), analogous to Unit in Scala.
** Control Flow
*** If expressions
**** Else blocks are optional, unlike Scala. If no else block is provided, and the condition evaluates to false, then the if block is skipped entirely and we move on to the next line.
**** Else blocks are not optional when you are assigning the result of an if block to a variable. Then it is treated as an expression and both sides are needed, resulting in a compile time error otherwise. Also the types in both the arms need to be the same, just like in Scala.
*** Loops
**** Like we saw in the guessing game chapter, a 'loop' just gives us an infinite loop.
* Understanding Ownership
** Languages like Java are garbage collected, while languages like C require you to manually manage the memory.
** Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. No run-time costs are incurred for any of the ownership features.
** The Stack and the Heap
*** Usually in most programming languages, we don't have to worry about the variable going into the stack or the heap. When I program in Java, this is usually the case.
*** But in a system's prog lang like Rust, it has more of an effect on how the program behaves.
*** Stack is a simple last in, first out data structure. All items on the stack must be of a known, fixed size. This and the previous property makes it very fast to use.
*** For data whose size is not known to us at compile time or whose size might change, we can store them on the heap instead.
*** When we allocate something here, we ask for the OS to find us an empty spot and give us a pointer to that location. This is called 'allocating on the heap' or more commonly 'allocating'.
*** Because a pointer always has a known, fixed size, they are pushed onto the stack.
*** Processors work better when they're working with data close to each other, like on a stack. Working with heap is slower, as is allocating a large amount of space on the heap.
*** When our code calls a function, the values passed in (including pointers to data) and the local variables in the fn are pushed onto the stack. When the fn is over, they're popped off.
** Ownership Rules
*** Each value in Rust has a variable that’s called its /owner/.
*** There can only be one owner at a time.
*** When the owner goes out of scope, the value will be dropped.
** All the variables we looked at in the data types chapter are stored on the stack and popped off when their scope is over.
** Memory and Allocation
*** For string literals, we know the exact amount of space needed to store them at compile time, making them very fast and efficient. We can't do the same for all strings. We can't just put a blob of memory into the binary for each piece of text whose size is unknown at compile time.
*** When we do 'String::new', it's implementation takes care of allocating space on the heap.
*** Deallocation
**** In languages with GC, this is done by that.
**** In manually managed langs like C, this is done by using a deallocation operation. This is tricky since if we forget, we waste memory. If we do it too early, we'll have an invalid variable. If we do it twice, that's a bug too.
**** We need exactly on pair of 'allocate' and 'free' statements.
**** In Rust, we return memory automatically when the variable goes out of scope.
**** When a variable goes out of scope, Rust calls a special function called 'drop'. This is the place where the author of String can put the code to return the memory.
**** In C++, this pattern of deallocating resources at the end of an item's lifetime is called Resource Acquisition Is Initialisation (RAII).
*** When we assign two strings to the same value, then when both go out of memory, then both might try to call free. This is known as double free error is one type of error that can occur.
*** Rust resolves this by invalidating the previous variable as soon as it is assigned to a new variable.
#+BEGIN_SRC rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world", s1);
#+END_SRC
*** In the above example, s1 is invalidated after the second line. This means the println line will not compile ensuring 'drop' is called only when 's2' goes out of scope.
*** This is neither a deep nor a shallow copy. We can consider this as a 'move', where s1 is moved into s2.
*** The advantage is that Rust will never automatically create deep copies of our data.
*** Types like integers have no notion of shallow or deep copy since they always reside on the stack. This is because we know their size at compile time itself.
*** Rust has a special annotation called the Copy trait. Types with this trait ensure that older variables are not invalidated when they are moved to newer variables.
*** Any type annotated with the Copy trait cannot also be annotated with the Drop trait.
*** All scalar types are Copyable. A tuple is copyable only if it contains scalar types.
*** Parameters to function calls behave the same way as let bindings. For scalar types, copies are made. For others, ownership is transferred onto the calling function.
*** When a variable is returned from a function, ownership is transferred to its caller.
** References and Borrowing
*** Borrowing and Immutable References
**** When we call a function as follows: calculate_length(&s1), we're not passing along ownership, but passing along a reference that refers to the value of s1.
**** We call having references as function parameters /borrowing/.
**** Just as variables are immutable by default, so are references. We cannot change something we borrowed. It is a compile time error.
*** Mutable Reference
**** The variable has to be marked as mutable, the function call has to pass a mutable reference, and the function itself must accept a mutable reference.
**** The big restriction is that you can have only one mutable reference to a particular piece of data in a particular scope.
**** This restriction allows for Rust to avoid data races at compile time.
**** Data Race
***** Two or more pointers access the same data at the same time
***** At least one of the pointers is being used to write to the data
***** There's no mechanism being used to synchronise access to the data
**** We also cannot have a mutable reference to something that already has an immutable reference
*** Dangling References
**** A pointer that references a location in memory that may have been give to someone else, when it was freed.
**** In Rust, the compile guarantees that there will be no dangling references.
** Slices
*** Taking a slice is very similar to getting a reference to the whole string, with the addition of specifying a range.
#+BEGIN_SRC rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+END_SRC
*** The type that indicates a String slice is written as &str.
*** String slices are immutable.
*** String literals are simply string slices that point to a specific point in the compiled binary.
*** String slices can also be used as parameters, by annotating parameter as &str instead of &String. This is more general and reusable.
*** There are other slices also, like below.
#+BEGIN_SRC rust
let a = [1, 2, 3, 4, 5];
let slice: &[i32] = &a[1..3];
#+END_SRC
